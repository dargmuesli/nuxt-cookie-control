import { resolve } from 'node:path'
import { pathToFileURL } from 'node:url'

import {
  defineNuxtModule,
  addPlugin,
  extendWebpackConfig,
  extendViteConfig,
  addImports,
  createResolver,
  resolvePath,
  addTypeTemplate,
  updateTemplates,
  installModule,
} from '@nuxt/kit'
import type { Nuxt, NuxtApp } from '@nuxt/schema'
import { defu } from 'defu'

import { CONFIG_KEY } from './constants'
import { replaceCodePlugin } from './replace'
import { DEFAULTS, type ModuleOptions } from './types'
import { name, version } from '../package.json'

const resolver = createResolver(import.meta.url)
const runtimeDir = resolver.resolve('./runtime')

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name,
    version,
    configKey: CONFIG_KEY,
    compatibility: { nuxt: '>=3.0.0' },
  },
  defaults: DEFAULTS,
  hooks: {
    'components:dirs'(dirs) {
      dirs.push({
        path: resolver.resolve(runtimeDir, 'components'),
        prefix: 'cookie',
      })
    },
  },
  async setup(moduleOptions, nuxt) {
    nuxt.options.alias['#cookie-control/set-vars'] =
      moduleOptions.isCssPonyfillEnabled
        ? resolver.resolve(runtimeDir, 'set-vars/ponyfill')
        : resolver.resolve(runtimeDir, 'set-vars/native')

    nuxt.options.alias['#cookie-control'] = runtimeDir
    nuxt.options.build.transpile.push('#cookie-control')

    // Import styles file
    nuxt.options.css.push(resolver.resolve('./runtime/styles.css'))
    // Install tailwindcss via nuxt module

    await installModule('@nuxtjs/tailwindcss', {
      // module configuration
      exposeConfig: true,
      viewer: false,
      config: {
        theme: {
          extend: {
            colors: moduleOptions.colors,
          },
        },
        darkMode: 'class',
        content: [
          resolver.resolve('./runtime/**/*.{vue,mjs,ts}'),
          resolver.resolve('./runtime/*.{mjs,js,ts}'),
        ],
      },
    })

    pushCss(moduleOptions, nuxt)
    blockIframes(moduleOptions)
    await loadLocales(moduleOptions)

    addPlugin(resolver.resolve(runtimeDir, 'plugin'))
    addImports({
      name: 'useCookieControl',
      as: 'useCookieControl',
      from: resolver.resolve(runtimeDir, 'composables'),
    })
    addTypeTemplate({
      filename: 'types/cookie-control.d.ts',
      getContents: getTypeTemplate,
      options: moduleOptions,
    })

    nuxt.hook('builder:watch', async (_event, path) => {
      if (path.includes(`${CONFIG_KEY}.cookies`)) {
        updateTemplates({
          filter: (t) => t.filename === 'types/cookie-control.d.ts',
        })
      }
    })

    nuxt.hook('modules:done', async () => {
      nuxt.options.runtimeConfig.public.cookieControl = defu(
        nuxt.options.runtimeConfig.public.cookieControl,
        moduleOptions,
      )
    })
  },
})

const blockIframes = (moduleOptions: ModuleOptions) => {
  if (moduleOptions.isIframeBlocked) {
    const isIframeBlocked = {
      id: 'ncc_f',
      name: 'functional',
    }

    if (moduleOptions.cookies) {
      if (moduleOptions.cookies.optional) {
        moduleOptions.cookies.optional.push(isIframeBlocked)
      } else {
        moduleOptions.cookies.optional = [isIframeBlocked]
      }
    }

    extendWebpackConfig((config) => {
      config.module?.rules?.push({
        test: /\.vue$/,
        loader: 'string-replace-loader',
        exclude: /node_modules/,
        options: {
          multiple: [
            { search: '<iframe', replace: '<CookieIframe', flags: 'g' },
            { search: '</iframe>', replace: '</CookieIframe>', flags: 'g' },
          ],
        },
      })
    })

    extendViteConfig((config) => {
      config?.plugins?.push(
        replaceCodePlugin({
          replacements: [
            {
              from: /<iframe[^>]*.*|<\/iframe>/g,
              to: (match: string) =>
                match.includes('cookie-enabled')
                  ? match
                  : match
                      .replace(/<iframe/g, '<CookieIframe')
                      .replace(/iframe>/g, 'CookieIframe>'),
            },
          ],
        }),
      )
    })
  }
}

const getTypeTemplate = (data: {
  nuxt: Nuxt
  app: NuxtApp
  options: ModuleOptions
}) => `// Generated by ${name}

/**
* Union of the cookie ids specified in the Nuxt configuration.
*/
export type CookieID = ${
  Object.values([
    ...data.options.cookies.necessary,
    ...data.options.cookies.optional,
  ])
    .map((cookie) => `"${cookie.id}"`)
    .join(' | ') || 'never'
}

export type CookieIDs = Array<CookieID>
`

const loadLocales = async (moduleOptions: ModuleOptions) => {
  const locales = moduleOptions.locales

  moduleOptions.locales = []

  for (const locale of locales) {
    const text = await import(
      pathToFileURL(await resolvePath(resolve(runtimeDir, 'locale', locale)))
        .href
    ).then((r) => r.default || r)

    if (!text) throw new Error(`Could not import text for locale ${locale}`)

    moduleOptions.locales.push(locale)
    moduleOptions.localeTexts[locale] = {
      ...text,
      ...moduleOptions.localeTexts[locale],
    }
  }
}

const pushCss = (moduleOptions: ModuleOptions, nuxt: Nuxt) => {
  if (moduleOptions.isCssEnabled)
    nuxt.options.css.push(resolver.resolve(runtimeDir, 'styles.css'))
}

declare module '@nuxt/schema' {
  interface PublicRuntimeConfig {
    cookieControl: ModuleOptions
  }
}
